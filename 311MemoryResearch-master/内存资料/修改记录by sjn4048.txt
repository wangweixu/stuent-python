内存修改记录·更新中
by sjn4048@ZJU

-----入门阶段-----

1.乱战改为霸王（完成）
把判定条件或者跳转nop掉

2.疾驰改为气力更高时伪报（完成）
改掉两个参数即可

-----实际修改-----

[搜索相关]
1.搜索金币上限增加、必搜到金币：并入富豪
①定位到相应代码：已完成
②修改最大值：已完成

2.新效果·寻宝概率提升（并入风水/眼力）
①定位到相应代码（完成）：
005D5B31                 call    sub_5D51D0 // 随机返回一个宝物
005D5B36                 mov     edi, eax   // edi中存的是宝物指针
...
005D5B49~5D5B66          eax = (61-宝物价值) / 20 (算术结果小于1时设为1)
// 值得注意的是，上边的代码段用了神奇的位运算+乘法代替了除法，如果要改参数的话要仔细计算一下
// 不在意这一点点性能、或者想改掉整个公式的话，直接写一个div，然后其他地方nop掉就好了。
005D5B6C                 call    sub_4721D0  // 调用随机函数，有[eax]%的概率搜到宝
005D5B71                 add     esp, 4      // 宝物价值为1的概率:3%，2~21:2%，价值>21:1%
005D5B74                 test    eax, eax
005D5B76                 jnz     short loc_5D5B7C // 如果没有命中以上概率，跳出到搜金币的过程
...
005D5B92                 call    sub_5D3D90 // 进入宝物结算过程（加经验、功绩，把宝物指针赋值给君主指针等）

②静态修改：
把5D5B76的jnz改为jmp的话，可以无条件搜宝物
如果要修改概率的话，可以修改5D5B49-5D5B66部分公式参数（比如把20改成10就是概率翻倍）
也可以修改5D5B6C的随机函数（调用自定义上限的随机函数，然后改上限）
代码复杂度应该差不多，效果是等价的。
我的改法（改掉除20的参数）：
005D5B45  0f b6 57 3c       movzx   edx, byte ptr [edi+3Ch] // edx = 宝物价值，不变
*005D5B49 e9 b2 a4 34 00    jmp 00920000
// 新增代码段，位于920000
00920000  b8 3d 00 00 00    mov     eax, 3Dh                // eax = 61
00920005  2b c2             sub     eax, edx                // eax = eax - edx
00920007  b9 14 00 00 00    mov     ecx, 14h                // ecx = 20
0092000C  99                cdq
0092000D  f7 f9             idiv    ecx                     // eax = eax / ecx
0092000F  50                push    eax                     // 保护eax寄存器，因为判断特技会用到eax
00920010  6a 61             push    061h                    // 检验是否为风水
00920012  8b ce             mov     ecx, esi
00920014  E8 d7 90 B6 FF    call    004890f0
00920019  85 C0             test    eax, eax
0092001B  58                pop     eax                     // 恢复eax
0092001C  0f 84 06 00 00 00 je      00920028                // 不是风水的话直接跳过乘法
00920022  69 c0 14 00 00 00 imul    eax,eax,14              // *20
00920028  e9 34 5b cb ff    jmp     005D5B61                // 跳回

[君主技·内政行动力消耗-1]
关键点位置：
军团改变行动力：004A1820
军团行动(会调用上一个函数消耗行动力)：005B9340
巡查：5CBF95
市场等内政建设：5BC4C1
商人：5CAD1B
征兵：5C3CAB
生产军马（是否也是其他兵装还需验证）：5C67B3
研究技巧：5D8F68
吸收合并：5D758B

*具体修改还没做


[新增菜单等]
以鬼门为切入点开始研究。
在00578186附近代码段中，[esi+001144](绝对地址0019B0E4)内存区域为显示的菜单数量
在00578186设置断点，直到显示出UI，函数调用链为：
   00578186（断点，在出门点击格子之后调用）
-> 调用006173D0（返回一个int）后返回
-> 57979B（判断上层return的int，如果为0的话返回）
-> ???

菜单的显示数量的所有引用：
*结论：所有的计算都已经在点击格子的那一刻完成了

“鬼門”(小端序F9AAADB0)位置：（绝对地址）
007EB968
“內訌”位置：
007EB400

“落雷”位置：
007EB0AC

结论：菜单显示的文字所在位置为007EBxxx，尝试将内讧改为“測試”(小端序D5B8FAB4)，修改后测试成功。
对“内讧”文字所在地址007EB400监视，可以发现在0070EC96和0070F1DD两处引用了这一值。其中，0070EC96为write_string()函数。因此，真正调用的部分是0070F1DD。此外，伏兵：7EB210，伪报7EB970。猜测先输出计略名字，然后输出计略后边的(消耗气力)，按这个思路筛选搜索，得到存放气力的内存区域：019927C（在堆栈里）

猜测运行逻辑：在点格子时候确认有几个可以用的计略，在点击到计略的时候取文本、输出。

同理，授予没收（ACA653A8)：007ECD34, 007ECD38
“探索”(C1AFB4B1)：007EB684 -> 多人(48A468A6)
“人材”(F7A748A4)：007EB688, 007E89F4 -> 探索(C1AFB4B1)

·逻辑部分
函数调用栈：（从下到上调用，最上边是断点）
   5D4160(断点：啥也没发现的结算)  此时武将指针（赵弘）在ebx=[ebp+8]=728B2F0(这个值是恒定储存在内存区中的信息，可以通过CE搜索)
-> 5D5C07(位于5D5970函数)  此时武将(疑似二重)指针在esi=[edi+4]中
-> 5B95D6(位于5B95D0函数)  此时武将指针在esi里，被push进了5D5970
**-> 5757F8(位于575370函数)  这一层和上一层是通过函数指针之类的东西连接的。此时武将指针可能在ecx
-> 57645B(位于576310函数)  ???
-> 576594(位于576520函数)  传给上一层的是二级指针esi与esi[8],esi[9],esi[10],暂不知道是什么
-> 4D3B74(位于4D3AA0函数)  ???
-> 43D87D(位于43D7A0函数)(从这里已经是UI端了，因为出现了GetCursorPos等函数)(这里执行之后会显示结果)
-> 439FB6(位于439E10函数)(UI界面等待cursor的循环)

0048A123处调用了武将的政治。这一段的调用栈：
   48A123
-> 48A2E5
-> 48A2F6
-> 4A711D
-> 5D42A1(5D4160)
这段应该是属于具体搜索的子函数(同时应该也是叶函数)


与“褒赏”的函数调用交叉对比：
   4A1820(断点：减行动力)
-> 5B9381(5B9340)
-> 5B5F87(5B5D60) // 褒赏扣行动力、扣钱在这里
-> 5B9636(5B9630)
**-> 57586E(575370) // 各种调用的集中入口
-> 以下都是相同的

-> 5B5A33
-> 4BBA6E
-> 4BC8CF

[菜单修改]
绑定函数：575370
设定每个选单的数量：617890
决定是否亮起：5B58FA -> 5BBA6E

[多人搜索]
搜索的最高层：5B95D0
搜索的第二层：5D5970(参数为数组,push 城市指针，push (城市指针、武将指针)的指针)

相比之下，褒赏传进去的是一个城市ID和一个武将链表(在堆内存6EEFxxx上)。只要把链表内的一个一个遍历就可以了。

先在褒赏上边改，改法：
5B5E21:
lea    eax,[esp+18]
push   eax
lea    ecx,[edi+04]
call   47BED0     // 调用对链表的函数，获得下一个指针
mov    esi, [eax] // esi <- 武将指针，以上操作为褒赏自带的
push   esi        // 把武将指针推进去
push   [edi]      // [edi]为城池指针
mov    esi, esp   // esi 存的是栈指针，指向元组(城市，武将)
push   [edi]
push   esi
call   5D5970     // 调用搜索的第二层函数（下一种改法是调用第一层函数，原理大同小异）
add    esp, 10    // 补回栈帧
mov    eax,[esp+14] // 以下操作为褒赏自带的
mov    edi,[ebp+08]
inc    eax
mov    [esp+14],eax
mov    eax,[esp+18]
test   eax,eax
jne    005B5E21    // 跳回do...while
jmp    5D5ED2      // 遍历到链表的最后一个指针时，eax为NULL(0)，跳出。

另一种改法：
5B5E21:
lea    eax,[esp+18]
push   eax
lea    ecx,[edi+04]
call   47BED0     // 调用对链表的函数，获得下一个指针
mov    esi, [eax] // esi <- 武将指针
push   esi        // push 武将指针
push   [edi]      // push 城池指针
mov    esi, esp   // esi 存的是栈指针，指向元组(城市，武将)
push   [edi]      // push 元组指针

mov    edx, [9771590]  // edx <= 0084C068
mov    ecx, 9771590    // ecx <- 9771590
call   dword ptr [edx+2C]
test   eax eax
jne    005B5E21    // 跳回do...while
jmp    5D5ED2

单人褒赏：
EAX 06EEF1F8  00000000  00000000  // 这个不用管
EBX 00000193  00000193  00000193  // 似乎不会动
ECX 00000062  00000222  0000028A
EDX 00000005  0721D000  07243000
ESI 0720B520  0721D284  072430C4
EDI 0019F09C  0019F09C  0019F09C  // 不会动
EBP 0019F060  0019F060  0019E060  // 不会动
ESP 0019E898  0019E898  0019E898  // 堆栈似乎平衡了

堆栈(880->8A0)
20 B5 20 07 FA 0F 48 00
01 00 00 00 20 B5 20 07 
E2 5D 5B 00 ED 5D 5B 00 
14 00 00 00 9C F0 19 00

4E 56 4A 00 01 00 00 00 
84 D2 21 07 BA 5E 5B 00 
84 D2 21 07 01 00 00 00 
14 00 00 00 9C F0 19 00 
00 00 00 00 84 D2 21 07


[禅让]
57555C(修改了吸收合并):
mov ecx, esi
call     4866F0            // 取城市指针，eax<-城市首地址
mov      ecx, eax
mov      eax, [eax]
call     dword ptr [eax+40] // 通过城市指针取势力ID
push     eax               // eax<-势力编号
mov      ecx, 7201958
call     490AA0           // 通过势力ID获得势力指针，存于eax
push     0               // int
push     0               // void *
push     eax             // push势力指针
mov      ecx, 755895C
call     4B9080
jmp      576232

[改城市]
点击城市后的调用栈：
4843A0:
4B99E9(4B99B0):
5BC0BB(5BC0A0):
5BC542(5BC520):
5B9D18(5B9CC0):
575476(575370):

决定是否进入都市的函数部分在576520

----TODO----

[改地图]
纹理品质：8A5BBC
访问它的：44E3C0

-> 57645B(位于576310函数)  ???
-> 576594(位于576520函数)  传给上一层的是二级指针esi与esi[8],esi[9],esi[10],暂不知道是什么
-> 4D3B74(位于4D3AA0函数)  ???
-> 43D87D(位于43D7A0函数)(从这里已经是UI端了，因为出现了GetCursorPos等函数)(这里执行之后会显示结果)
-> 439FB6(位于439E10函数)(UI界面等待cursor的循环)

[传送]
获取移动力的函数：56DCE4
点击地图格的调用栈：
56DCE4


[搜索时候优先眼力]



[解除晋阳/洛阳 下邳/吴互相牵制]
考虑增加一个新的城市距离表（不改变飞调），将这两所城市距离拉远


[火攻使地方粮草减少] 减少数量：暂定为总兵粮/15+300

[特技重做·长驱]：骑兵冲锋伤害+150%；骑兵战法超过8格时眩晕敌军。
分析：骑兵冲锋效果属于新增代码段08xxxxx区域的，所以需要sire的源码（或者运行时内存环境）。后者参考疾驰。
疾驰

005C648A - e9 69 31 2e 00    - jmp 008a95f8
005C648F - 90 90             - nop nop
008A95F8 - 69 c0 64 00 00 00 - imul eax,eax,00000064
008A95FE - b9 64 00 00 00    - mov ecx,00000064
008A9603 - 99                - cdq
008A9604 - f7 f9             - idiv ecx
008A9606 - 89 44 24 10       - mov [esp+10],eax
008A960A - e9 82 ce d1 ff    - jmp 005c6491


[特技新增·定远]在领土范围外作战时，行动力+10，攻击力+20%
参考拱戍

[新增效果]骑兵二动（不可攻击）

[特技新增·兵仙]（韩信）最大领军数+3000；部队士兵越多，攻击力越强

[内政·设施不受火伤害]

[新增特技·传送] 传送至地图任意位置，需吟唱3回合。

[新增效果·火攻]火攻减兵粮/士气
【关键代码】
①部队减粮：004ae570：部队减粮（PUSH 减少粮草，PUSH 部队指针，ecx＝0799895c）
②火神
005AEBAF: 火神(62) 针对此特技持有者的火计成功率必为0
005AEC19: 火神(62) 对低智部队火计必成功
005B1263: 火神(62) 火计(火矢点火)对据点士兵伤害加倍，格子起火对部队兵伤害加倍，受到火计(火矢点火)时部队士兵不减
005B1686: 火神(62) 火陷阱对据点耐久损伤加倍，对部队士兵伤害加倍
005B178B: 火神(62) 火陷阱对部队士兵伤害无效，所在据点受到火陷阱伤害大幅降低
005AE540: 火神(62) 通过着火格不减兵
00583008: 火神(62) 船只着火不减兵
③判断有没有火攻特技：“火攻特技火陷阱伤害”

8b 13                      - mov edx,[ebx]
6a ??                      - push ??                            ??＝火攻
8b cb                      - mov ecx,ebx
ff 52 58                   - call dword ptr [edx+58]            判断被陷阱攻击是否有武将持有“火攻”特技
85 c0                      - test eax,eax
74 ??                      - je ??                              没有则跳过“火攻”处理
④调用火伤害函数：
RK文档里找，关键词：“火伤和主动部队兵力”

[火攻效果与智力相关]